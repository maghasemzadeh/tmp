+ شما باید کد هوش مصنوعی خود را در تابع turn که در فایل AI.java (در تمامی کلاینت‌ها فایلی با همین اسم قرار دارد)، پیاده‌سازی کنید.

+ شما می‌توانید کد کلاینت داده شده را تغییر دهید، به آن فایل اضافه کنید یا از آن فایل حذف کنید، به شرط آنکه تغییرات داده شده در کامپایل و اجرای کلاینت و ارتباط آن با سرور اختلالی ایجاد نکند. در مورد هر کلاینت نکاتی ذکر شده که به آن‌ها نیز باید توجه شود. همچنین باید تغییرات احتمالی فایل‌های دیگر کلاینت، یعنی فایل‌هایی غیر از فایلی که در آن کد می‌زنید) را در نظر بگیرید.

+ شما می‌توانید برای به روز بودن کلاینت‌ها یا سرور خود به آخرین نسخه منتشر شده در repository مسابقه مراجعه کنید.
  
  * [کلاینت C++](https://github.com/SharifAIChallenge/AIC20-Client-Cpp)
  * [کلاینت Java](https://github.com/SharifAIChallenge/AIC20-Client-Java)
  * [کلاینت Python](https://github.com/SharifAIChallenge/AIC20-Client-Python)

# کلاینت جاوا

کلاینت‌های جاوا، برای اجرا توسط سرور، باید به فایل jar تبدیل شوند. برای ساخت فایل jar کلاینت جاوا، باید از Intellij استفاده کنید. در Intellij، از مسیر زیر می‌توانید فایل jar رابسازید.  

`File --> Project Structure --> Project Settings --> Artifacts --> green plus sign --> Jar --> From modules with dependencies`

![jar](https://github.com/maghasemzadeh/tmp/blob/main/jar.png?raw=true)

هر بار که تغییری در کد کلاینت داده شد، برای اجرا باید یک فایل jar تازه ساخته‌شود. مراحل ساخت فایل jar و اطلاعات بیشتر را در [داکیومنتیشن Intellij](https://www.jetbrains.com/help/idea/compiling-applications.html#compile_module) و همچنین [این پست در Stack Overflow](https://stackoverflow.com/questions/1082580/how-to-build-jars-from-intellij-properly) نیز می‌توانید مشاهده کنید.

# کلاینت پایتون

برای اجرای کلاینت‌های پایتون، باید کدها و تمامی dependency ها در یک پکیج تجمیع شود (Binary). این کار با ابزار [Pyinstaller](https://pypi.org/project/pyinstaller/) به راحتی امکان‌پذیر است. برای نصب این پکیج، می‌توانید از دستور pip install pyinstaller استفاده کنید. اگر pip را نصب ندارید، طریقه‌ی نصب آن روی سیستم‌عامل‌های مختلف، از لینک‌های زیر مشاهده کنید:  

  * [Windows](https://phoenixnap.com/kb/install-pip-windows)

  * [Linux](https://www.tecmint.com/install-pip-in-linux/)

  * [Mac OS](https://ahmadawais.com/install-pip-macos-os-x-python/)

دقت کنید که پس از هر بار تغییر در کد، پوشه های build و dist را پاک کنید و مجددا با PyInstaller بیلد بگیرید.

# اجرای سرور

برای اجرای سرور آخرین نسخه ریلیز سرور را از این ریپو دانلود کنید (فایل server.jar). سپس سرور را به این شکل اجرا کنید:  
`java -jar server.jar --first-team=/path/to/first/client --second-team=/path/to/second/client`
  
در بالا دو آرگومان اول محل قرار گیری فایل کلاینت برای تیم اول و تیم دوم را مشخص می کنند. این فایل برای کلاینت جاوا همان فایل jar تولید شده است ، برای کلاینت پایتون خروجی باینری و برای کلاینت cpp همان خروجی حاصل از بیلد گرفتن کلاینت است.  
  
دقت کنید که اگر فایل کلاینت شما در پوشه سرور قرار دارد (مثلا نام آن client است) از ./ در ابتدای آن استفاده کنید:  
`--first-team=./client`

برای نمایش لاگ بیشتر از سرور جهت دیباگ کردن (و همچنین نمایش خروجی کلاینت ها در لاگ سرور) از آرگومان `--show-log` نیز  می‌توانید استفاده کنید.  
مثال:   
`java -jar server.jar --first-team=/path/to/first/client --second-team=/path/to/second/client --show-log`
  
با استفاده از آرگومان ```--max-agent``` می توانید یک کران بالا برای تعداد نیرو های ساخته شد (instance های اجرایی از کلاینت) تعیین کنید تا سیستم شما دچار مشکل در اجرا نشود (پیشنهاد ما حداکثر ۵۰ است)

مثال:  
 `java -jar server.jar --first-team=/path/to/first/client --second-team=/path/to/second/client --max-agent=20`
 این مقدار به طور پیش فرض 200 در نظر گرفته می شود.
در صورت تمایل به اجرای کلاینت ها بصورت دستی، می توانید از آرگومان `--run-manually` استفاده کنید. در این صورت هر موقع سرور منتظر وصل شدن کلاینت جدید ماند، باید یک instance از کلاینت خود را دستی اجرا کنید. در این صورت می توانید به طور کامل لاگ کلاینت را در کنسول مشاهده کنید. (در این صورت توصیه می شود از اعداد کوچک برای `inital_ant_num` در `map.config` استفاده کنید.)

+ برای تست کردن کد، با تعداد کم نیرو این روش بسیار مفید خواهد بود. ضمن این که برای اجرا در این روش نیازی به خروجی گرفتن از کلاینت نیست.  

+ دقت کنید که هرموقع نیاز به کلاینت جدید بود، سرور در خروجی ای رشته را چاپ می کند:  
`Run a new instance of your client, waiting...`

# نکات
## بازی
در کلاینت‌ها، زمین بازی و خانه‌های آن (Cell) طبق مختصات زیر مقداردهی می شوند:

+ خانه‌ی بالا چپ زمین مختصات (0,0) دارد.
+ مقدار x برای هر خانه، شماره ستون آن (از چپ) است.
+ مقدار y برای هر خانه، شماره سطر آن (از بالا) است. 

## سایر نکات

+ در بین دستوراتی که از کلاینت‌ها به سرور فرستاده می‌شود، در صورت نامعتبر بودن یک دستور، این دستور نادیده گرفته می‌شود.

+ رفرنس شی World و شی‌های درونی آن در هر نوبت از ابتدا ساخته می‌شود رفرنس‌های نوبت قبل در نوبت فعلی معتبر نیستند.

## سایر توضیحات

+ اطلاعات نقشه بازی در یک فایل به نام `map.config` در کنار سرور بازی باید قرار بگیرد که نمونه ی آن را در ریپو سرور می توانید پیدا کنید. 

+ خروجی گرافیکی سرور پس از پایان یک بازی در یک فایل به نام `log.json` در کنار سرور قابل دسترسی است.

+ در هنگام اجرای سرور حتما به درست وارد کردن آدرس کلاینت های بازی دقت کنید!

+ برای مطمین شدن از این که سرور کار خود را با موفقیت به پایان رسانده است، در خروجی باید winner مشخص شده باشد. (نه لزوما خط آخر)

# توابع و کلاس‌های اصلی کلاینت

`Answer turn(World)`

این تابع در هر نوبت بازی صدا زده می شود. هر نیرو در آن نوبت یک شی Answer تولید می‌کند که از جهت حرکت نیرو و پیام (در صورت ارسال پیام) و ارزش آن تشکیل شده است.  

### World/Game

`Ant getAnt()`
اطلاعات آن نیرو را برمی‌گرداند.

`AntType getAntType()`

نوع نیرو فعلی را برمی گرداند که یکی از دو حالت SARBAAZ و یا KARGAR است.

`ChatBox getChatBox()`

اطلاعات چت باکس تیم نیرو فعلی را بر می‌گرداند. ( لیستی از پیام ها و نوبتی که در آن پیام ارسال شده است)

`int getMapWidth()`

عرض زمین بازی را برمی گرداند.

`int getMapHeight()`

ارتفاع زمین بازی را برمی گرداند.

`int getBaseX()`

مختصات X پایگاه تیم نیرو فعلی را بر می گرداند.

`int getBaseY()`

مختصات Y پایگاه تیم نیرو فعلی را بر می گرداند.

`int getHealthKargar()`

مقدار جان اولیه کارگر را بر می گرداند.

`int getHealthSarbaaz()`

مقدار جان اولیه نیرو های سرباز را بر می گرداند.

`int getAttackDistance()`

فاصله منهتنی برای حمله نیرو سرباز را برمی گرداند.

`int getGenerateKargar()`

مقدار منبع مورد نیاز برای تولید کارگر را برمی گرداند.

`int getGenerateSarbaaz()`

مقدار منبع مورد نیاز برای تولید سرباز را برمی گرداند.

`int getRateDeathResource()`

مقدار پارامتر RateDeathResource را برمی گرداند.

### Ant

`Cell getMapCell(int xStep, int yStep)`

خانه مربوطه بر روی نقشه را در صورتی که در دید نیرو باشد (view_distance) بر می گرداند. (اگر در دید نیرو فعلی نباشد، این مقدار null بر می گرداند)

`int getXCoordinate() `

مختصات X خانه فعلی نیرو را بر می گرداند.

`int getYCoordinate() `

مختصات Y خانه فعلی نیرو را بر می گرداند.

`AntType getType()`

نوع نیرو فعلی را بر می گرداند

`AntTeam getTeam()`

تیم نیرو را بر می گرداند. (شی Ant برای نیرو های خانه های همسایه نیز قابل استفاده است).

* ALLIED → هم تیمی نیرو فعلی

* ENEMY → تیم مقابل نیرو فعلی

`Resource getCurrentResource()`

مقدار و نوع منبعی که نیرو فعلی حمل می کند را بر می گرداند.

`int getHealth()`

میزان جان مورجه فعلی را بر می گرداند.

`getViewDistance()`

مقدار پارامتر view distance را برای نیرو فعلی بر می گرداند.

# ایرادات و مشکلات

در صورتی که در اجرای سرور به مشکلی بر خوردید، از طریق سایت، یک تیکت در قالب زیر برای ما ارسال کنید:

+ .شرح مشکل پیش آمده

+ کدی که در بخش AI برای کلاینت خود زدید بعلاوه نوع کلاینتی که استفاده می کنید.

+ لاگ خروجی سرور پس از اجرا که در آدرس Log/server/server.log در کنار سرور قرار می‌گیرد ( برای خروجی مفصل تر،‌ سرور را با --show-log اجرا کنید سپس این فایل را بفرستید).

+ فایل  map.config استفاده شده.

+ کامندی که با آن سرور را اجرا می‌کنید (با آرگومان‌ها).

در صورتی که در اجرا و کارکردن با هر یک کلاینت ها به مشکل برخوردید، از طریق سایت، یک تیکت در قالب زیر ارسال کنید:

+ شرح مشکل پیش آمده.

+ نوع کلاینتی که استفاده می‌کنید (پایتون، جاوا یا سی‌پی‌پی).

+ کد کامل کلاینت به صورت فشرده (zip)
